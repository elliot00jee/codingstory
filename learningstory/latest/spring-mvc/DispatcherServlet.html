<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>DispatcherServlet :: mypage</title>
    <link rel="canonical" href="https://elliot00jee.github.io/mypage/learningstory/latest/spring-mvc/DispatcherServlet.html">
    <meta name="generator" content="Antora 3.1.2">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <link rel="stylesheet" href="../../../_/css/site-extra.css">
    <link rel="icon" href="../../../favicon.ico" type="image/x-icon">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <div class="navbar-item">
        <a href="https://elliot00jee.github.io/mypage">mypage</a>
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="learningstory" data-version="latest">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">learningstory</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Spring MVC</span>
<ul class="nav-list">
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="DispatcherServlet.html">DispatcherServlet</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">자바의 기본</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../java-basic/variable.html">변수</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../java-basic/enum.html">Enum</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../java-basic/lamda_and_functional_interface.html">함수형 인터페이스와 람다</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">learningstory</span>
    <span class="version">default</span>
  </div>
  <ul class="components">
    <li class="component">
      <a class="title" href="../../../codingstory/latest/index.html">CodingStory</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../codingstory/latest/index.html">default</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <a class="title" href="../index.html">learningstory</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">default</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../TIL/latest/index.html">TIL</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../TIL/latest/index.html">default</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../codingstory/latest/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">learningstory</a></li>
    <li>Spring MVC</li>
    <li><a href="DispatcherServlet.html">DispatcherServlet</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/elliot00jee/mypage/edit/main/learningstory/docs/modules/spring-mvc/pages/DispatcherServlet.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">DispatcherServlet</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>스프링 MVC는 프론트 컨트롤러 패턴으로 구현되어 있으며, 여기서 프론트 컨트롤러 역할을 하는 것이 <code>DispatcherSevlet</code> 이며, 스프링 MVC의 핵심이라고 할 수 있다. <code>DispatcherServlet</code> 도 부모 클래스에서 <code>HttpServlet</code> 클래스를 상속받아 서블릿으로 동작한다.</p>
</div>
<div class="paragraph">
<p>서블릿이 호출되면 <code>HttpServlet</code> 의 <code>service()</code> 메소드가 호출되게 된다. 스프링 MVC는 <code>DispatcherServlet</code> 의 부모인 <code>FrameworkServlet</code> 에서 <code>servie()</code> 메소드를 구현해두었고, 이 부분을 시작으로 <code>DispatcherServlet</code> 의 <code>doDispatch()</code> 메소드가 시작된다.</p>
</div>
<div class="paragraph">
<p>첫 번째로, <code>@RequestMapping</code> 어노테이션이 붙은 컨트롤러(핸들러)에 해당하는 요청이 들어왔을 경우를 확인해보자.</p>
</div>
<div class="listingblock">
<div class="title">HelloController.jaa</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class HelloController {
    @Autowired
    HelloService helloService;

    @GetMapping("/first")
    @ResponseBody
    public String first() {
        return "Hello, Stranger.";
    }
}</code></pre>
</div>
</div>
<div id="DispatcherServlet" class="listingblock">
<div class="title">DispatcherServlet.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
    HttpServletRequest processedRequest = request;
    HandlerExecutionChain mappedHandler = null;
    boolean multipartRequestParsed = false;
    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

    try {
        try {
            ModelAndView mv = null;
            Exception dispatchException = null;

            try {
                processedRequest = this.checkMultipart(request);
                multipartRequestParsed = processedRequest != request;
                mappedHandler = this.getHandler(processedRequest); <i class="conum" data-value="1"></i><b>(1)</b>
                ...
}

protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
    // 1. org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping
    //    스프링 빈의 이름으로 핸들러를 찾는다.
    // 2. org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping
    //    어노테이션 기반의 컨트롤러인, @RequestMapping이 붙은 핸들러를 찾는다.
    // 3. org.springframework.web.servlet.function.support.RouterFunctionMapping
    if (this.handlerMappings != null) {
        Iterator var2 = this.handlerMappings.iterator();

        while(var2.hasNext()) {
            HandlerMapping mapping = (HandlerMapping)var2.next();
            HandlerExecutionChain handler = mapping.getHandler(request); <i class="conum" data-value="2"></i><b>(2)</b>
            if (handler != null) {
                return handler;
            }
        }
    }
    return null;
}

protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
                ...
                if (mappedHandler == null) {
                    this.noHandlerFound(processedRequest, response);
                    return;
                }

                HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler()); <i class="conum" data-value="3"></i><b>(3)</b>
                ...
}

protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {
    // 1. org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter
    // 2. org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter
    // 3. org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter
    // 4. org.springframework.web.servlet.function.support.HandlerFunctionAdapter
    if (this.handlerAdapters != null) {
        Iterator var2 = this.handlerAdapters.iterator();

        while(var2.hasNext()) {
            HandlerAdapter adapter = (HandlerAdapter)var2.next();
            if (adapter.supports(handler)) {
                return adapter; <i class="conum" data-value="4"></i><b>(4)</b>
            }
        }
    }

    throw new ServletException("No adapter for handler [" + handler + "]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler");
}

protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
                ...
                String method = request.getMethod();
                boolean isGet = HttpMethod.GET.matches(method);
                if (isGet || HttpMethod.HEAD.matches(method)) {
                    long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
                    if ((new ServletWebRequest(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) {
                        return;
                    }
                }

                if (!mappedHandler.applyPreHandle(processedRequest, response)) {
                    return;
                }

                mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); <i class="conum" data-value="5"></i><b>(5)</b>
                ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>해당 요청을 처리할 수 있는 핸들러를 찾아오는 메소드를 호출한다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>등록 되어있는 <code>HandlerMapping</code> 을 차례로 돌면서 해당 요청을 처리할 수 있는 핸들러를 찾아서 반환한다.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>해당 핸들러를 실행할 수 있는 핸들러 어댑터를 찾아오는 메소드를 호출한다.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>등록 되어있는 <code>HandlerAdapter</code> 를 차례로 돌면서 해당 핸들러를 실행시킬 수 있는 핸들러 어댑터를 찾아서 반환한다.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>찾아온 핸들러 어댑터에서 실제 요청을 처리하는 메소드를 호출한다.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">RequestMappingHandlerAdapter.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Nullable
    protected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {
    ServletWebRequest webRequest = new ServletWebRequest(request, response);

    Object result;
    try {
        WebDataBinderFactory binderFactory = this.getDataBinderFactory(handlerMethod);
        ModelFactory modelFactory = this.getModelFactory(handlerMethod, binderFactory);
        ServletInvocableHandlerMethod invocableMethod = this.createInvocableHandlerMethod(handlerMethod);
        if (this.argumentResolvers != null) {
            invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
        }

        if (this.returnValueHandlers != null) {
            invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
        }
        ...
        invocableMethod.invokeAndHandle(webRequest, mavContainer, new Object[0]); <i class="conum" data-value="1"></i><b>(1)</b>
        if (!asyncManager.isConcurrentHandlingStarted()) {
            ModelAndView var15 = this.getModelAndView(mavContainer, modelFactory, webRequest);
            return var15;
        }

        result = null;
    } finally {
        webRequest.requestCompleted();
    }

    return (ModelAndView)result;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>해당 요청을 실행하는 메소드를 호출한다.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">ServletInvocableHandlerMethod.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {
    Object returnValue = this.invokeForRequest(webRequest, mavContainer, providedArgs); <i class="conum" data-value="1"></i><b>(1)</b>
    ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>핸들러를 호출한다. 리플렉션을 사용하여 해당 메소드를 invoke 시킨다.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">HelloController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/first")
public String hello() {
    return "Hello, Stranger";
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">ServletInvocableHandlerMethod.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {
    ...
    this.setResponseStatus(webRequest);
    if (returnValue == null) { <i class="conum" data-value="1"></i><b>(1)</b>
        if (this.isRequestNotModified(webRequest) || this.getResponseStatus() != null || mavContainer.isRequestHandled()) {
            this.disableContentCachingIfNecessary(webRequest);
            mavContainer.setRequestHandled(true);
            return;
        }
    } else if (StringUtils.hasText(this.getResponseStatusReason())) {
        mavContainer.setRequestHandled(true);
        return;
    }

    mavContainer.setRequestHandled(false);
    Assert.state(this.returnValueHandlers != null, "No return value handlers");

    try {
        this.returnValueHandlers.handleReturnValue(returnValue, this.getReturnValueType(returnValue), mavContainer, webRequest); <i class="conum" data-value="2"></i><b>(2)</b>
    } catch (Exception var6) {
        if (logger.isTraceEnabled()) {
            logger.trace(this.formatErrorForReturnValue(returnValue), var6);
        }

        throw var6;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>@RestController</code> 일 경우에, <code>returnValue</code> 는 문자열이 된다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>returnValue</code> 를 처리할 수 있는 핸들러를 찾아서 실행시키기 위해 <code>returnValueHandlers</code> 의 메소드를 호출한다.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">HandlerMethodReturnValueHandlerComposite.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class HandlerMethodReturnValueHandlerComposite implements HandlerMethodReturnValueHandler {
    // .. RequestResponseBodyMethodProcessor
    private final List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers = new ArrayList();
    ...
    public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {
        HandlerMethodReturnValueHandler handler = this.selectHandler(returnValue, returnType); <i class="conum" data-value="1"></i><b>(1)</b>
        ...
    }
    private HandlerMethodReturnValueHandler selectHandler(@Nullable Object value, MethodParameter returnType) {
        boolean isAsyncValue = this.isAsyncReturnValue(value, returnType);
        Iterator var4 = this.returnValueHandlers.iterator();

        HandlerMethodReturnValueHandler handler;
        do {
            do {
                if (!var4.hasNext()) {
                    return null;
                }

                handler = (HandlerMethodReturnValueHandler)var4.next();
            } while(isAsyncValue &amp;&amp; !(handler instanceof AsyncHandlerMethodReturnValueHandler));
        } while(!handler.supportsReturnType(returnType)); <i class="conum" data-value="2"></i><b>(2)</b>

        return handler;
    }
    ...
    public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {
        ...
        if (handler == null) {
            throw new IllegalArgumentException("Unknown return value type: " + returnType.getParameterType().getName());
        } else {
            handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest); <i class="conum" data-value="3"></i><b>(3)</b>
        }
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>returnType</code> 을 처리할 수 있는 핸들러를 찾는 메소드를 호출한다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>HandlerMethodReturnValueHandler</code> 의 구현체들이 구현하고 있는 <code>supportsReturnType</code> 메소드를 호출해서, <code>returnType</code> 을 지원하는 핸들러인지 확인한다.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>위에서 찾은 응답 핸들러를 실행해서 <code>returnValue</code> 를 처리한다.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">RequestResponseBodyMethodProcessor.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public boolean supportsReturnType(MethodParameter returnType) { <i class="conum" data-value="1"></i><b>(1)</b>
    return AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseBody.class) || returnType.hasMethodAnnotation(ResponseBody.class);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>RequestResponseBodyMethodProcessor</code> 응답 핸들러는 클래스 또는 메소드에 <code>@ResponseBody</code> 어노테이션이 붙어있는 <code>returnType</code> 을 처리할 수 있다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>지금처럼 <code>@ResponseBody</code> 가 붙은 핸들러에 해당하는 요청을 처리하는 경우에는, <a href="#DispatcherServlet">DispatcherServlet</a> 에서 핸들러 어댑터를 통해 요청을 처리한 뒤의 반환 값인 <code>mv</code> 는 <code>null</code> 이 된다. <code>@ResponseBody</code> 가 붙지 않았지만 <code>returnType</code> 이 문자열인 경우에는</p>
</div>
<div class="listingblock">
<div class="title">HelloController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class HelloController {
    @GetMapping("/first")
    @ResponseBody
    public String hello() {
        return "Hello, Stranger.";
    }

    @GetMapping("/second")
    public String second() {
        return "/WEB-INF/second.jsp";
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">ViewNameMethodReturnValueHandler.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ViewNameMethodReturnValueHandler implements HandlerMethodReturnValueHandler {

    public boolean supportsReturnType(MethodParameter returnType) {
        Class&lt;?&gt; paramType = returnType.getParameterType();
        return Void.TYPE == paramType || CharSequence.class.isAssignableFrom(paramType);
    }

    public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {
        if (returnValue instanceof CharSequence) { <i class="conum" data-value="1"></i><b>(1)</b>
            String viewName = returnValue.toString();
            mavContainer.setViewName(viewName);
            if (this.isRedirectViewName(viewName)) {
                mavContainer.setRedirectModelScenario(true);
            }
        } else if (returnValue != null) {
            throw new UnsupportedOperationException("Unexpected return type: " + returnType.getParameterType().getName() + " in method: " + returnType.getMethod());
        }

    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>returnValue</code> 를 <code>viewName</code> 으로 판단하여 <code>ModelAndViewContainer</code> 객체에 값을 세팅한다.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">RequestMappingHandlerAdapter.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Nullable
    protected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {
        ...
        invocableMethod.invokeAndHandle(webRequest, mavContainer, new Object[0]);
        if (!asyncManager.isConcurrentHandlingStarted()) {
            ModelAndView var15 = this.getModelAndView(mavContainer, modelFactory, webRequest); <i class="conum" data-value="1"></i><b>(1)</b>
            return var15;
        }

        result = null;
    } finally {
        webRequest.requestCompleted();
    }

    return (ModelAndView)result;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>핸들러에서 <code>ModelAndViewContainer</code> 객체에 값을 세팅한 것을 가지고 <code>ModelAndView</code> 객체를 생성해서 리턴한다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>두 번째로, <code>Controller</code> 인터페이스를 구현한 컨트롤러(핸들러)에 해당하는 요청이 들어왔을 경우를 확인해보자. 이 경우에 사용되는 핸들러 매핑은 <code>BeanNameUrlHandlerMapping</code> 이고, 이 핸들러를 실행시킬 수 있는 핸들러 어댑터는 <code>SimpleControllerHanlderAdapter</code> 가 된다.</p>
</div>
<div class="listingblock">
<div class="title">SimpleController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller("/simple")
public class SimpleController implements org.springframework.web.servlet.mvc.Controller {
    @Override
    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
        return new ModelAndView("/WEB-INF/simple.jsp");
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_정리"><a class="anchor" href="#_정리"></a>정리</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_dispatcherservlet_동작_순서"><a class="anchor" href="#_dispatcherservlet_동작_순서"></a>DispatcherServlet 동작 순서</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>요청을 분석한다. (로케일, 테마, 멀티파트 등)</p>
</li>
<li>
<p>(핸들러 맵핑에게 위임하여) 요청을 처리할 핸들러를 찾는다.</p>
</li>
<li>
<p>(등록되어 있는 핸들러 어댑터 중에) 해당 핸들러를 실행할 수 있는 핸들러 어댑터를 찾는다.</p>
</li>
<li>
<p>찾아낸 핸들러 어댑터를 사용해서 핸들러의 응답을 처리한다.</p>
<div class="ulist">
<ul>
<li>
<p>핸들러의 리턴값을 보고 어떻게 처리할지 판단한다.</p>
</li>
<li>
<p>뷰 이름에 해당하는 뷰를 찾아서 모델 데이터를 랜더링한다.</p>
</li>
<li>
<p><code>@ResponseBody</code> 가 있다면 Converter를 사용해서 응답 본문을 만들고.</p>
</li>
</ul>
</div>
</li>
<li>
<p>(부가적으로) 예외가 발생했다면, 예외 처리 핸들러에 요청 처리를 위임한다.</p>
</li>
<li>
<p>최종적으로 응답을 보낸다.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">DispatcherServlet.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected void initStrategies(ApplicationContext context) { <i class="conum" data-value="1"></i><b>(1)</b>
    this.initMultipartResolver(context);
    this.initLocaleResolver(context);
    this.initThemeResolver(context);
    this.initHandlerMappings(context);
    this.initHandlerAdapters(context);
    this.initHandlerExceptionResolvers(context);
    this.initRequestToViewNameTranslator(context);
    this.initViewResolvers(context);
    this.initFlashMapManager(context);
}
private void initViewResolvers(ApplicationContext context) {
    this.viewResolvers = null;
    if (this.detectAllViewResolvers) {
        Map&lt;String, ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, ViewResolver.class, true, false); <i class="conum" data-value="2"></i><b>(2)</b>
        if (!matchingBeans.isEmpty()) {
            this.viewResolvers = new ArrayList(matchingBeans.values());
            AnnotationAwareOrderComparator.sort(this.viewResolvers);
        }
    } else { <i class="conum" data-value="3"></i><b>(3)</b>
        try {
            ViewResolver vr = (ViewResolver)context.getBean("viewResolver", ViewResolver.class);
            this.viewResolvers = Collections.singletonList(vr);
        } catch (NoSuchBeanDefinitionException var3) {
        }
    }

    if (this.viewResolvers == null) {
        this.viewResolvers = this.getDefaultStrategies(context, ViewResolver.class); <i class="conum" data-value="4"></i><b>(4)</b>
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("No ViewResolvers declared for servlet '" + this.getServletName() + "': using default strategies from DispatcherServlet.properties");
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>서블릿이 초기화 <code>init()</code> 될 때 한 번만 호출된다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>ViewResolver</code> 타입의 빈들을 찾아와서 <code>viewResolvers</code> 리스트에 넣어둔다.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>기본적으로 <code>detectAllViewResolvers</code> 는 <code>true</code> 값을 갖지만, <code>false</code> 인 경우 빈 이름이 정확하게 <code>viewResolver</code> 이면서 <code>ViewResolver</code> 타입의 빈을 하나만 가져와서 넣는다. 일반적으로 <code>detectAllViewResolver</code> 는 기본 값을 사용한다.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>이 때, 등록된 <code>ViewResolvers</code> 타입의 빈들이 없다면 <code>DispatcherServlet.properties</code> 에 정의된 기본 전략을 사용한다.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">DispatcherServlet.properties</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver</code></pre>
</div>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>Copyright © <a href="https://opendevise.com">OpenDevise Inc.</a> and individual contributors to <a href="https://antora.org">Antora</a>. Site deploys by <a href="https://netlify.com">Netlify</a>.</p>
  <p>Except where otherwise noted, docs.antora.org, Antora, and the Antora UI, are licensed under the <a href="https://www.mozilla.org/en-US/MPL/2.0/">Mozilla Public License Version 2.0</a> (MPL-2.0).</p>
  <p>AsciiDoc® is a trademark of the Eclipse Foundation, Inc.</p>
</footer>
<script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
