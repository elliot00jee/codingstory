<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>함수형 인터페이스와 람다 :: mypage</title>
    <link rel="canonical" href="https://elliot00jee.github.io/mypage/learningstory/latest/java-basic/lamda_and_functional_interface.html">
    <meta name="generator" content="Antora 3.1.2">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <link rel="stylesheet" href="../../../_/css/site-extra.css">
    <link rel="icon" href="../../../favicon.ico" type="image/x-icon">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <div class="navbar-item">
        <a href="https://elliot00jee.github.io/mypage">mypage</a>
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="learningstory" data-version="latest">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">learningstory</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Spring MVC</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../spring-mvc/DispatcherServlet.html">DispatcherServlet</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">자바의 기본</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="variable.html">변수</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="enum.html">Enum</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="lamda_and_functional_interface.html">함수형 인터페이스와 람다</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">learningstory</span>
    <span class="version">default</span>
  </div>
  <ul class="components">
    <li class="component">
      <a class="title" href="../../../codingstory/latest/index.html">CodingStory</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../codingstory/latest/index.html">default</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <a class="title" href="../index.html">learningstory</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">default</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../TIL/latest/index.html">TIL</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../TIL/latest/index.html">default</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../codingstory/latest/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">learningstory</a></li>
    <li>자바의 기본</li>
    <li><a href="lamda_and_functional_interface.html">함수형 인터페이스와 람다</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/elliot00jee/mypage/edit/main/learningstory/docs/modules/java-basic/pages/lamda_and_functional_interface.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">함수형 인터페이스와 람다</h1>
<div class="sect1">
<h2 id="_람다"><a class="anchor" href="#_람다"></a>람다</h2>
<div class="sectionbody">
<div class="paragraph">
<p>람다는 자바 1.8 부터 지원되는 기능이다. 람다의 도입으로 인해 자바는 객체지향 언어인 동시에 함수형 프로그래밍도 가능한 언어가 되었다. 자바에서의 함수는 매개변수로 전달할 수 있고 반환 타입에도 사용 가능한 일급 객체로 취급되는데, 람다의 타입으로 사용하기 위한 함수형 인터페이스도 도입되었다. 메서드를 재정의하여 원하는 동작을 구현하기 위한 방법으로 자주 사용했었던 템플릿 메서드 패턴 외에도, 함수 객체를 매개 변수로 받는 메소드를 사용하여 구현할 수 있게 되었다. 컬렉션 인터페이스들에도 함수형 인터페이스와 람다를 사용한 다양한 디폴트 메서드가 추가되기도 했다.</p>
</div>
<div class="sect2">
<h3 id="_람다식"><a class="anchor" href="#_람다식"></a>람다식</h3>
<div class="paragraph">
<p>람다식은 메서드를 하나의 식(expression)으로 표현한 것으로, 함수형 인터페이스를 인라인으로 구현한 특수한 형태의 객체이다. 이름 없는 함수이기 때문에 <code>익명 함수</code> 라고도 한다.</p>
</div>
<div class="listingblock">
<div class="title">Example1</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">int max(int a, int b) {
    return a &gt; b ? a : b;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>위와 같은 메서드를 람다식으로 변환하면 다음과 같다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">(int a, int b) -&gt; { return a &gt; b ? a : b }; <i class="conum" data-value="1"></i><b>(1)</b>
(int a, int b) -&gt; a &gt; b ? a : b <i class="conum" data-value="2"></i><b>(2)</b>
(a, b) -&gt; a &gt; b ? a : b <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>반환 타입 및 매서드 이름을 삭제하고, 중간에 <code>&#8594;</code> 를 추가한다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>간단한 한 줄의 반환 타입으로 이루어질 경우, <code>중괄호({})</code> 와 <code>return</code>, <code>세미콜론(;)</code> 을 삭제할 수 있다.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>타입 추론이 가능한 대부분 경우 매개변수의 타입도 삭제할 수 있다. (전부 삭제하거나 전부 넣거나 해야 한다.)</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Example2</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">int value(int a) {
    return a;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>위 처럼 매개 변수가 하나인 경우 타입을 생략한다면 <code>괄호(())</code> 도 삭제 가능하다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">(int a) -&gt; a <i class="conum" data-value="1"></i><b>(1)</b>
a -&gt; a</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>타입이 있을 경우 괄호도 있어야 한다.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Example3</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">void value() {
    System.out.println("람다식을 공부해봐요.");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>위 처럼 매개변수가 없을 경우에는 <code>()</code> 로 표현해야 한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">() -&gt; System.out.println("람다식을 공부해봐요.")</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_함수형_인터페이스"><a class="anchor" href="#_함수형_인터페이스"></a>함수형 인터페이스</h2>
<div class="sectionbody">
<div class="paragraph">
<p>람다식을 어떻게 만드는지는 알아봤는데, 그렇다면 위 람다식을 호출하기 위해서는 어떻게 할까? 일반 메소드의 경우 해당 메소드 이름으로 호출하게 되지만 람다식은 이름이 없다. 자바에서는 함수도 객체라고 했다. 람다식의 타입은 어떻게 될까?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">타입 f = (a, b) -&gt; a &gt; b ? a : b</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>자바에서는 람다식의 타입으로 <code>함수형 인터페이스</code> 를 사용하도록 한다.</p>
<div class="ulist">
<ul>
<li>
<p>람다식의 매개변수의 타입과 개수, 반환값이 일치하는 인터페이스 메소드가 있다면 해당 람다식의 타입으로 사용할 수 있다.</p>
</li>
<li>
<p>함수형 인터페이스는 <code>static</code> 메소드와 <code>default</code> 메소드를 제외하고 단 하나의 메소드만 정의되어 있어야 한다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>엄밀히 말하면 람다식은 익명 객체이고 타입이 존재하지 않는데, 함수형 인터페이스의 타입으로 형변환이 가능하며, 이를 생략한 것이다.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">@FunctionalInterface
interface FunctionalInterface {
    int max(int a, int b);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>이는 인터페이스나 클래스를 익명 클래스를 사용해서 구현하는 것과도 같은 흐름이다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">FuntionalInterface 익명내부클래스 = new FuntionalInterface() {
    @Override
    public int max(int a, int b) {
        return a &gt; b ? a : b;
    }
};

FuntionalInterface 람다 = (a, b) -&gt; a &gt; b ? a : b;</code></pre>
</div>
</div>
<div class="paragraph">
<p>위에서 보면 인터페이스에 <code>@FunctionalInterface</code> 어노테이션을 사용했다.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>해당 인터페이스가 람다용으로 설계된 함수형 인터페이스임을 알려준다.</p>
</li>
<li>
<p>이 어노테이션이 붙어있을 경우, 추상 메서드를 하나만 가질 수 있도록 컴파일 시에 체크해준다.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_표준_함수형_인터페이스"><a class="anchor" href="#_표준_함수형_인터페이스"></a>표준 함수형 인터페이스</h3>
<div class="paragraph">
<p><code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html">java.util.function</a></code> 패키지에는 일반적으로 자주 쓰이는 형식의 메소드를 함수형 인터페이스로 미리 정의해놓았다. 대부분은 직접 구현하지 않고도 표준 함수형 인터페이스를 사용할 수 있을 것이고, 유용한 디폴트 메소드들도 많이 제공하기 때문에 미리 알아놓으면 좋다.</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">인터페이스</th>
<th class="tableblock halign-center valign-top">함수 시그니처</th>
<th class="tableblock halign-left valign-top">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Function&lt;T, R&gt;</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">R apply(T t)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T 타입을 받아서 R 타입을 리턴</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">BiFunction&lt;T, U, R&gt;</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">R apply(T t, U u)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">매개변수로 T, U 두 개의 타입을 받아서 R 타입을 반환</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Supplier&lt;T&gt;</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">T get()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">인자는 없고 T 타입을 반환</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Consumer&lt;T&gt;</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">void accept(T t)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T 타입을 받고 반환값은 없음</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Predicate&lt;T&gt;</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">boolean test(T t)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T 타입을 받고 boolean 타입을 반환</p></td>
</tr>
</tbody>
</table>
<div id="Function" class="listingblock">
<div class="title">Function&lt;T, R&gt;</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@FunctionalInterface
public interface Function&lt;T, R&gt; {
    R apply(T t);

    default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) {
        Objects.requireNonNull(before);
        return (V v) -&gt; apply(before.apply(v));
    }

    default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) {
        Objects.requireNonNull(after);
        return (T t) -&gt; after.apply(apply(t));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Function&lt;T, R&gt;</code> 인터페이스를 사용해서 매개변수에 10을 더하거나, 2를 곱하는 람다식을 작성해보면 다음과 같다. 이 때, 매개변수와 반환값은 모두 <code>Integer</code> 이다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Function&lt;Integer, Integer&gt; plus10 = (i) -&gt; i + 10;
Function&lt;Integer, Integer&gt; multiply2 = (i) -&gt; i * 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>위는 식을 정의한 것이고, 실제로 함수가 실행되기 위해서는 <code>apply()</code> 메소드를 호출해야 한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">plus10.apply(10); // 12
multiply2.apply(10); // 20</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#Function">Function&lt;T, R&gt;</a> 을 보면 <code>compose</code> 와 <code>andThen</code> 디폴트 함수를 볼 수 있는데 두 가지의 <code>Function</code> 람다식을 조합해서 새로운 람다식을 생성한다.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>compose()</code> 는 매개변수로 또 다른 <code>Function&lt;V, R&gt;</code> 람다식을 받아서 <code>apply()</code> 를 먼저 실행한다. 그리고 여기서 반환된 값을 매개변수로 하여 <code>apply()</code> 를 실행한다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Function&lt;Integer, Integer&gt; compose = plus10.compose(multiply2);
// Function&lt;Integer, Integer&gt; compose = (v) -&gt; plus10.apply(multiply2.apply(v)); <i class="conum" data-value="1"></i><b>(1)</b>
compose.apply(5); // 60 <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>결국 <code>compose()</code> 메소드에서 반환되는 람다식은 이렇다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>먼저 <code>multiply2</code> 의 <code>apply()</code> 가 실행되어 <code>50</code> 이 반환되고, <code>50</code> 은 <code>plus10</code> 의 매개변수로 들어가서 <code>apply()</code> 가 실행되어 <code>60</code> 이 반환된다.</td>
</tr>
</table>
</div>
</li>
<li>
<p><code>andThen()</code> 는 먼저 현재 <code>this</code> 객체의 <code>apply()</code> 를 실행한다. 그리고 여기서 반환된 값을 매개변수로 하여 <code>andThen()</code> 메소드의 매개변수로 받았던 객체의 <code>apply()</code> 를 실행한다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Function&lt;Integer, Integer&gt; andThen = plus10.compose(multiply2);
// Function&lt;Integer, Integer&gt; andThen2 = (t) -&gt; multiply.apply(plus10.apply(t)); <i class="conum" data-value="1"></i><b>(1)</b>
andThen.apply(5); // 150 <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>결국 <code>andThen()</code> 메소드에서 반환되는 람다식은 이렇다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>먼저 <code>apply</code> 의 <code>apply()</code> 가 실행되어 <code>15</code> 가 반환되고, <code>15</code> 은 <code>multiply2</code> 의 매개변수로 들어가서 <code>apply()</code> 가 실행되어 <code>150</code> 이 반환된다.</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>위에서 작성해본 예제는 <code>Integer</code> 를 매개변수로 받아서 같은 타입을 리턴한다. <code>java.util.function</code> 패키지에는 하나의 타입을 받아서 같은 타입을 리턴하는 <code>UnaryOperator&lt;T&gt;</code> 가 존재한다.</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">인터페이스</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">함수 시그니처</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">설명</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">UnaryOperator&lt;T&gt;</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">T apply(T t)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Function&lt;T, T&gt; 를 상속받은 인터페이스로 매개변수로 받은 타입과 반환 타입이 일치한다.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">BinaryOperator&lt;T&gt;</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">R apply(T t, U u)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BiFunction&lt;T,T,T&gt; 를 상속받은 인터페이스로 매개변수 2개와 반환 타입이 모두 일치한다.</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">UnaryOperator&lt;Integer&gt; plus10 = (i) -&gt; i + 10;
plus10.apply(2); // 12
BinaryOperator&lt;Integer&gt; max = (a, b) -&gt; a &gt; b ? a : b;
max.apply(1, 3); // 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>지금까지는 제네릭 타입으로 함수형 인터페이스를 사용하기 위해서 박싱된 기본 타입을 사용했다. 자바는 기본형을 위한 함수형 인터페이스도 제공한다.</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">인터페이스</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">함수 시그니처</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">설명</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">IntFunction&lt;R&gt;</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">R apply(int value)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T 타입을 받아서 int 타입을 반환</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">DoubleFunction&lt;R&gt;</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">R apply(double value)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T 타입을 받아서 double 타입을 반환</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">LongFunction&lt;R&gt;</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">R apply(long value)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long 타입을 받아서 R 타입을 반환</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">ToDoubleFunction&lt;T&gt;</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">double applyAsDouble(T value)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T 타입을 받아서 double 타입을 반환</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">ToIntFunction&lt;T&gt;</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">int applyAsInt(T value)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T 타입을 받아서 int 타입을 반환</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">ToLongFunction&lt;T&gt;</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">long applyAsLong(T value)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T 타입을 받아서 long 타입을 반환</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">IntUnaryOperator</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">int applyAsInt(int operand)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int 타입을 받아서 int 타입을 반환</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">IntFunction&lt;Integer&gt; plus10 = (i) -&gt; i + 10;
plus10.apply(2); // 12
IntUnaryOperator plus10_unary = (i) -&gt; i + 10;
plus10_unary.applyAsInt(2) // 12</code></pre>
</div>
</div>
<div class="paragraph">
<p>이 외에도 제일 위에서 살펴본 <code>Consumer</code>, <code>Predicate</code>, <code>Supplier</code> 인터페이스도 마찬가지로 기본형 인터페이스를 제공한다.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_람다식과_메소드_참조"><a class="anchor" href="#_람다식과_메소드_참조"></a>람다식과 메소드 참조</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_람다식의_로컬_변수_사용"><a class="anchor" href="#_람다식의_로컬_변수_사용"></a>람다식의 로컬 변수 사용</h3>
<div class="paragraph">
<p>람다식은 익명 구현 객체, 로컬 클래스와 마찬 가지로 바깥 클래스의 모든 필드와 메소드에 접근 가능하다. 그리고 메소드 내에서 정의되었을 경우, 메소드 내에서 정의된 지역 변수도 사용 가능하다. 하지만 이 지역 변수들은 메소드의 실행이 끝나면 스택 메모리에서 사라진다. 정의한 람다식의 참조가 남아 있어 실행 가능할 경우 어떻게 될까?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class LambdaStudy {

    private String classVar = "[클래스 멤버 변수]";
    private Supplier&lt;String&gt; lambda;

    <i class="conum" data-value="1"></i><b>(1)</b>
    public void createLambda(String argVar) {
        String localVar = "[로컬 변수]";
        lambda = () -&gt; argVar + " " + localVar + " " + this.classVar;
    }

    public static void main(String[] args) {
        LambdaStudy lambdaStudy = new LambdaStudy();
        lambdaStudy.createLambda("[매개 변수]"); <i class="conum" data-value="2"></i><b>(2)</b>

        System.out.println(lambdaStudy.lambda.get()); <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>lambda</code> 라는 람다식을 정의한다. 이 식 안에는 매개 변수인 <code>argVar</code> 와 로컬 변수인 <code>localVar</code> 가 사용되었다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>argVar</code> 에 값을 넘겨주면서 메소드를 호출한다. 그리고 메소드가 종료되면 내부의 지역 변수들은 사라진다.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>실행 결과는 <code>[매개 변수] [로컬 변수] [클래스 멤버 변수]</code> 이다. 사라진 지역 변수들에 대한 값도 갖고 있다. 어떻게 된 걸까?</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>인텔리제이에서 지원하는 바이트코드 보기 기능으로 확인해보면 아래와 같은 부분을 볼 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc"><i class="conum" data-value="1"></i><b>(1)</b>
private synthetic lambda$createLambda$0(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
L0
LINENUMBER 12 L0
ALOAD 1
ALOAD 2
ALOAD 0
GETFIELD study/lambda/LambdaStudy.classVar : Ljava/lang/String;
INVOKEDYNAMIC makeConcatWithConstants(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; [
  // handle kind 0x6 : INVOKESTATIC
  java/lang/invoke/StringConcatFactory.makeConcatWithConstants(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;
  // arguments:
  "\u0001 \u0001 \u0001"
]
ARETURN
L1

LOCALVARIABLE this Lstudy/lambda/LambdaStudy; L0 L1 0
LOCALVARIABLE argVar Ljava/lang/String; L0 L1 1 <i class="conum" data-value="2"></i><b>(2)</b>
LOCALVARIABLE localVar Ljava/lang/String; L0 L1 2
MAXSTACK = 3
MAXLOCALS = 3
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>synthetic</code> 은 자바 컴파일러에 의해 생성된 메소드를 가리킨다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>람다식에서 사용했던 메소드 내의 지역 변수들을 (또는 참조 값) 그대로 복사해온다는 걸 알 수 있다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>익명 구현 객체와 로컬 클래스도 마찬 가지이다. 그렇다면, 람다식에서 해당 지역 변수를 복사해간 이후에 메소드에서 해당 값을 바꿔 버리면 어떻게 될까? 자바는 이것을 막기 위해 <code>final</code> 로 선언된 변수만 사용 가능 하도록 하여 변수를 초기화한 이후에는 값을 변경할 수 없도록 했다. 자바 8 부터는 <code>final</code> 변수가 아니라도, 변수를 초기화한 이후에 값이 변경되지 않는 다면 <code>사실상 final</code> 변수로 판단하여 사용 가능하다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void createLambda(String argVar) {
    String localVar = "[로컬 변수]";
    lambda = () -&gt; argVar + " " + localVar + " " + this.classVar; <i class="conum" data-value="1"></i><b>(1)</b>

    localVar = "값을 변경하고 싶습니다";
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>localVar</code> 값을 초기화한 후에 변경하려고 할 경우 (위치와 상관 없이) 에러가 발생 한다.
<div class="ulist">
<ul>
<li>
<p><code>Variable used in lambda expression should be final or effectively final</code></p>
</li>
<li>
<p><code>final</code> 과는 달리 선언과 동시에 값을 초기화하지 않더라도 컴파일 에러는 발생하지 않는다.</p>
</li>
<li>
<p>람다 내부에서도 사용되는 변수 임을 명시적으로 표시하기 위해 <code>final</code> 을 사용하는게 좋을 것 같아 보인다.</p>
</li>
</ul>
</div></td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_람다식의_스코프"><a class="anchor" href="#_람다식의_스코프"></a>람다식의 스코프</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class WhatIsThis {
    public void createLambda() {
        String name = "JAVA";
        Supplier&lt;String&gt; lambda = () -&gt; {
            String name = "Stranger"; <i class="conum" data-value="1"></i><b>(1)</b>
            return "Hello, " + name;
        };
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>컴파일 에러가 발생한다.
<div class="ulist">
<ul>
<li>
<p><code>Variable 'name' is already defined in the scope</code></p>
</li>
</ul>
</div></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>새로운 스코프를 생성하는 익명 클래스나 로컬 클래스와는 다르게, 람다식은 람다식을 정의한 메소드와 동일한 스코프기 때문에 같은 이름의 변수를 선언할 수 없다. 익명 클래스나 로컬 클래스 내부에서 <code>this</code> 를 사용하면 익명 클래스의 객체, 로컬 클래스의 객체 참조를 가리키지만, 람다식에서의 <code>this</code> 는 람다식을 실행하는 객체의 참조를 가진다.</p>
</div>
</div>
<div class="sect2">
<h3 id="_메소드_참조"><a class="anchor" href="#_메소드_참조"></a>메소드 참조</h3>
<div class="paragraph">
<p>람다가 하는 일이 기존 메소드 또는 생성자 같은 단 하나의 메소드만 호출하는 경우에는 메소드 레퍼런스를 사용해서 매우 간결하게 표현할 수 있다.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>메소드 또는 생성자의 매개변수로 람다의 입력값을 받는다.</p>
</li>
<li>
<p>리턴값 또는 생성한 객체는 람다의 리턴값이다.</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all fit-content">
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">종류</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">람다</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">메소드 참조</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">정적 메소드 참조</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(x) &#8594; ClassName.method(x)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">ClassName::method</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">특정 인스턴스 메소드 참조</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(x) &#8594; object.method(x)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">object::method</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">인스턴스 메소드 참조</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(object, x) &#8594; object.method(x)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">ClassName::method</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">생성자 메소드 참조</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">() &#8594; new ClassName()</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">ClassName::new</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="_정적_메소드_참조"><a class="anchor" href="#_정적_메소드_참조"></a>정적 메소드 참조</h4>
<div class="paragraph">
<p>두 개의 <code>int</code> 를 매개 변수로 받아서 더한 뒤 결과 <code>int</code> 를 리턴하는 람다식을 만들고 싶을 때 사용할 수 있는 함수형 인터페이스는 <code>BinaryOperator</code> 이다.</p>
</div>
<div id="lambda1" class="listingblock">
<div class="title">lambda</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">IntBinaryOperator sum = (a, b) -&gt; a + b;</code></pre>
</div>
</div>
<div class="paragraph">
<p>자바 8부터 <code>Interger</code> 클래스에서는 <code>sum</code> 이라는 정적 함수를 제공하는데, 우리가 위에서 구현한 것과 동일한 동작이다.</p>
</div>
<div class="listingblock">
<div class="title">Integer.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public final class Integer extends Number implements Comparable&lt;Integer&gt; {
    /**
     * Adds two integers together as per the + operator.
     *
     * @param a the first operand
     * @param b the second operand
     * @return the sum of {@code a} and {@code b}
     * @see java.util.function.BinaryOperator
     * @since 1.8
     */
    public static int sum(int a, int b) { <i class="conum" data-value="1"></i><b>(1)</b>
        return a + b;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>위 함수를 사용하도록 람다식을 바꿔보자.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">IntBinaryOperator sum = (a, b) -&gt; Integer.sum(a, b);</code></pre>
</div>
</div>
<div class="paragraph">
<p>위 람다식은 단순히 메소드 하나만 호출하는 것이기 때문에 다음과 같이 메소드 참조로 변경할 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">IntBinaryOperator sum = Integer::sum;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_특정_인스턴스의_메소드_참조"><a class="anchor" href="#_특정_인스턴스의_메소드_참조"></a>특정 인스턴스의 메소드 참조</h4>
<div class="paragraph">
<p>객체를 생성해서 메소드 하나를 호출하는 람다식을 만들어보자.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class Foo {
    public String getName() {
        return "Stranger";
    }
}
public void studyingMethodRef() {
    Foo foo = new Foo();
    Supplier&lt;String&gt; supplier = () -&gt; foo.getName();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>위 람다식은 다음과 같이 메소드 참조로 변경할 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void studyingMethodRef() {
    Foo foo = new Foo();
    Supplier&lt;String&gt; supplier = foo::getName;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_임의_인스턴스의_메소드_참조"><a class="anchor" href="#_임의_인스턴스의_메소드_참조"></a>임의 인스턴스의 메소드 참조</h4>
<div class="paragraph">
<p><code>Arrays</code> 클래스에는 정렬 메소드가 있는데, 아래는 알파벳 순으로 정렬된다. 이 때 대문자가 소문자보다 우선 순위가 높다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String[] names = {"Jake", "Amy", "Holt", "boyle", "gina"};
Arrays.sort(names); // Amy, Holt, Jake, boyle, gina</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Arrays</code> 클래스에는 <code>Comparator</code> 라는 함수형 인터페이스를 파라미터로 받는 정렬 메소드도 있다.</p>
</div>
<div class="listingblock">
<div class="title">Arrays.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) {
    if (c == null) {
        sort(a);
    } else {
        if (LegacyMergeSort.userRequested)
            legacyMergeSort(a, c);
        else
            TimSort.sort(a, 0, a.length, c, null, 0, 0);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Comparator.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@FunctionalInterface
public interface Comparator&lt;T&gt; {
    int compare(T o1, T o2);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>대소문자에 상관없이 정렬하고 싶다면 <code>String</code> 클래스의 <code>compareToIgnoreCase()</code> 를 사용할 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public int compareToIgnoreCase(String str) {
    return CASE_INSENSITIVE_ORDER.compare(this, str);
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String[] names = {"Jake", "Amy", "Holt", "boyle", "gina"};
Arrays.sort(names, (o1, o2) -&gt; o1.compareToIgnoreCase(o2)); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>처음 공부할 때 여길 이해하는게 뭔가 어려웠는데, 풀어서 생각해보면 쉽다. <code>Arrays.sort</code> 메소드는 정렬 과정에서 아래 같은 식으로 <code>comparator.compare()</code> 메소드를 호출하게 될텐데, 앞의 <code>o1</code> 은 <code>String</code> 의 <code>this</code> 객체가 되는 것이고, <code>o2</code> 는 <code>compareToIgnoreCase()</code> 메소드의 파라미터로 넘겨지게 되는 것이다.
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Comparator&lt;String&gt; comparator = (o1, o2) -&gt; o1.compareToIgnoreCase(o2);
int result = comparator.compare("Jake", "Amy");</code></pre>
</div>
</div></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>위의 람다식은 아래처럼 메소드 참조로 변경할 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String[] names = {"Jake", "Amy", "Holt", "boyle", "gina"};
Arrays.sort(names, String::compareToIgnoreCase);</code></pre>
</div>
</div>
<div class="paragraph">
<p>보면 임의 인스턴스의 메소드 참조와 정적 메소드 참조는 형태가 동일하지만, 실제 메소드가 <code>static</code> 인지 아닌지로 구분할 수 있다.</p>
</div>
</div>
<div class="sect3">
<h4 id="_생성자_메소드_참조"><a class="anchor" href="#_생성자_메소드_참조"></a>생성자 메소드 참조</h4>
<div class="paragraph">
<p>람다식에서 단순히 객체를 생성하기만 한다면 생성자 메소드 참조로 변경할 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Supplier&lt;Foo&gt; supplier = () -&gt; new Foo();
Foo foo = supplier.get();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Supplier&lt;Foo&gt; supplier = Foo::new;
Foo foo = supplier.get();</code></pre>
</div>
</div>
<div class="paragraph">
<p>위에서는 기본 생성자를 사용했기 때문에 매개 변수는 없고, 반환 타입은 <code>Foo</code> 타입인 <code>Supplier&lt;Foo&gt;</code> 인터페이스를 사용했다. 매개 변수가 있는 생성자를 호출할 때는 어떻게 될까?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Foo foo = new Foo("hello");
Function&lt;String, Foo&gt; function = str -&gt; new Foo(str);
Foo foo = function.apply("hello");</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Foo foo = new Foo("hello");
Function&lt;String, Foo&gt; function = Foo::new;
Foo foo = function.apply("hello");</code></pre>
</div>
</div>
<div class="paragraph">
<p>생성자가 오버로딩 되었을 때, 생성자 참조만 놓고보면 형태가 동일하기 때문에 어떤 것을 호출하게 될지 알 수 없다. 컴파일 시에 매칭되는 생성자가 존재하지 않으면 에러가 발생한다.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_참고_및_출처"><a class="anchor" href="#_참고_및_출처"></a>참고 및 출처</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://blog.frankel.ch/synthetic/">Synthetic</a></p>
</li>
<li>
<p><a href="https://www.inflearn.com/course/the-java-java8/dashboard">인프런 - 더 자바, Java 8</a></p>
</li>
<li>
<p><a href="https://product.kyobobook.co.kr/detail/S000061695652">도서 - 이것이 자바다</a></p>
</li>
<li>
<p><a href="https://product.kyobobook.co.kr/detail/S000001550352">도서 - 자바의 정석</a></p>
</li>
</ul>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>Copyright © <a href="https://opendevise.com">OpenDevise Inc.</a> and individual contributors to <a href="https://antora.org">Antora</a>. Site deploys by <a href="https://netlify.com">Netlify</a>.</p>
  <p>Except where otherwise noted, docs.antora.org, Antora, and the Antora UI, are licensed under the <a href="https://www.mozilla.org/en-US/MPL/2.0/">Mozilla Public License Version 2.0</a> (MPL-2.0).</p>
  <p>AsciiDoc® is a trademark of the Eclipse Foundation, Inc.</p>
</footer>
<script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
